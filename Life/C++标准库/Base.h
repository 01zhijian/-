#pragma once
class Base
{
};

/* ------------------------------ 学习笔记 ------------------------------ *

C++ 对 C 的扩展
- 类型增强：类型检查更严格、有不布尔类型（bool）、真正的枚举、表达式的值可被赋值
- 重载的底层实现：name mangling（改变命名）。实现原理：用 v-c-i-f-l-d 表示 void
	char、int、float、long、double
- 引用的概念：变量名，本身是一段内存的引用，即别名（alias）。
	引用的本质：C++ 对裸露的内存地址（指针）作了一次包装。
- 尽可能使用 const
	1、使用 const 可以避免无意修改数据的编程错误
	2、使用 const 可以处理 const 和非 const 实参。否则将只能接受非const 数据
	3、使用 const 引用，可使函数能够正确的生成并使用临时变量（如果实参与引用参
		数不匹配，就会生成临时变量）

应用场景：替换掉某些使用指针的场景

- new 和 delete 关键字
	1、效率比 malloc 和 free 高
	2、配对使用，避免内存泄露和多重释放
	3、避免交叉使用

- 内联函数
	优点：避免调用时的额外开销（入栈与出栈操作）
	代价：由于内联函数的函数体在代码段中会出现多个“副本”，因此会增加代码段的空间
	本质：以牺牲代码段空间为代价，提高程序运行时间的效率
	适用场景：函数体很“小”，且被“频繁”调用

- 静态类型转换：在一个方向上可以作隐式转换，在另一个方向上就可以做静态转换
- 重解释类型转换：通常为操作数的位模式提供较低层的重新解释，也就是说将数据以二进
	制存在形式的重新解释，在双方向上都不可以隐式类型转换的，则需要重解释类型转换
- （脱）常类型转换：通常是未来函数能够接受这个实际参数
- 动态类型转换：用于多态中的父子类之间的强制转换

命名空间：支持嵌套、协作开发

string 数组是高效的，如果用二维数组来存入字符串数组的话，则容易浪费空间，此时列
	数是由最长的字符串决定。如果用二级指针申请堆空间，依据大小申请相应的空间，
	虽然解决了内存浪费的问题，但是操作麻烦。用 string 数组存储，字符串数组的话，
	效率即高又灵活

编程建议
- 在 C++ 中几乎不需要用宏，用 const 或 enum 定义现实的常量，用 inline 避免函数
	调用的额外开销，用模板去刻画一族函数或类型，用 namespace 去避免命名冲突
- 不要在你需要变量之前去声明，以保证你能立即对它进行初始化
- 不要用 malloc，new 运算会做的更好
- 避免使用 void*、指针算术、联合和强制，大多数情况下，强制都是设计错误的指示器
- 尽量少用数组和 C 风格的字符串，标准库中的 string 和 vector 可以简化程序
- 更加重要的是，试着将程序考虑为一组由类和对象表示的相互作用的概念，而不是一堆
	数据结构和一些可以拨弄的二进制

- 拷贝构造
	由已存在的对象，创建新对象，也就是说新对象，不由构造器来构造，而是由拷贝构造
	器来完成。
	规则：1）系统提供默认的拷贝构造器，一经实现，不复存在；2）系统提供的等位拷贝
	也就是所谓的浅拷贝，要实现深拷贝，必须要自定义
	发生时机：1）制作对象的副本；2）以对象作为参数和返回值

- this 指针
	系统在创建对象时，默认生成指向当前对象的指针。目的是为了带来方便
	作用：1）避免构造器的入参与成员名相同；2）基于 this 指针的自身引用还被广泛地
	应用于那些支持多重串联调用的函数中，比如连续赋值

- 赋值运算符重载
	发生时机：用一个已有对象给另外一个已有对象赋值。两个对象均已创建结束后，发生
	的赋值行为
	规则：1）系统提供默认的赋值运算符重载，一经实现，不复存在；2）系统提供默认的
	等位拷贝，也就是浅拷贝，会造成内存泄露，重析构，要实现深拷贝，必须自定义；3）
	自定义面临的问题有三个：自赋值、内存泄露、重析构；5）返回不用 const 修改的引用

- C++ 返回栈对象
- C++ 返回栈对象引用：返回栈对象引用，多用于产生串联应用。比如连等式。栈对象是
	不可以返回引用的。除非，函数的调用者返回自身对象。如果非要返回栈对象的引用
	会发生一次拷贝构造，但是拷贝构造的对象在拷贝之前已经析构了，所以结果是未知的

- const 修饰符
	常数据成员：const 修饰类的成员变量，表示成员变量，不能被修改，同时它只能在
	初始化列表中赋值。可被 const 和非 const 成员函数调用，而不可以修改
	常成员函数：承诺在本函数内部不会修改类内的数据成员，不会调用其它非 const 成
	员函数
	小结
	1）如果 const 构成函数重载，const 对象只能调用 const 函数，非 const 对象优先
	调用非 const 函数
	2）const 函数只能调用 const 函数。非 const 函数可以调用 const 函数
	3）类体外定义的 const 成员函数，在定义和声明处都需要 const 修饰符
	常对象：1）const 对象，只能调用 const 成员函数；2）可访问 const 或非 const 
	数据成员，不能修改

- static 修饰符
	1）static 成员变量实现了同族类对象间信息共享
	2）static 成员类外存储，求类大小，并不包含在内
	3）static 成员是命名空间属于类的全局变量，存储在 data 区 rw 段
	4）static 成员使用时必须初始化，且只能类外初始化
	5）可以通过类名访问（无对象生成亦可），也可以通过对象访问
	类静态成员函数的定义：为了管理静态成员，C++ 提供了静态函数，以对外提供接口。
	并静态函数只能访问静态成员。静态成员函数，不在于信息共享，数据沟通，而在于
	管理静态数据成员，完成对静态数据成员的封装；静态成员函数只能访问静态数据成员，
	原因是非静态成员函数，在调用时 this 指针被当作参数传进。而静态成员函数属于类，
	而不属于对象，没有 this 指针

- 同类对象间无私处，异类对象间有友员
	友员目的的本质，是让其它不属于本类的成员（全局函数，其它类的成员函数），成为
	类的成员而具备了类成员的属性。注意事项：1）友员关系不能被继承；2）友元关系是
	单向的；3）友元关系不具有传递性

- 向前声明，是一种不完全型声明，即只需提供类名（无需提供类实现）即可。正因为是不
	完全类型，功能上存在如下限制
		1）不能定义类的对象
		2）可以用于定义指向这个类型的指针或引用
		3）用于声明（不是定义），使用该类型作为形参类型或者函数的返回值类型

- 常见的错误类型
	申请的内存多次释放：程序出现异常
	内存泄露：忘记 delete
	释放的内存不是申请时的地址：程序崩溃
	释放空指针：最好不要
	释放一个内存块，但继续引用其中的内容：异常或崩溃
	越界访问：异常或崩溃











*/
class A_
{
	
};

class B
{
	friend class A_;
};
struct MyInt
{
	int val;
};

MyInt operator+(MyInt self, MyInt other)
{
	return MyInt{ self.val + other.val };
}

