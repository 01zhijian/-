
/* ------------------------------ 学习笔记 ------------------------------ *
template <typename DataType>
告诉编译器两件事：
    1）这是一个函数模板：一个由此可以创建函数的模式
    2）标志符 DataType 是这个函数模板的一个类型形参的名字，当函数被调用时，
    将被给定一个值

    使用类型形参 DataType 代替了某个特定的类型，定义的剩余部分则简单地规定了程序
的行为。在函数模板的内部和外部，它都没有做任何事。当编译器碰到一个模板，例如
swap()，它只是简单的存储这个模板而不会产生任何实际的机器指令。它在根据需要的
基础上使用模板给出的模式来产生实际的函数定义。

使用 typedef 来活得这种通用性存在着一些问题
    1）因为改变 typedef 就是改变头文件，那么任何使用这个类的程序或者库都需要重新编译
    2）假设需要两个不同值类型的容器，例如，一个实数类型的 Stack 和一个字符型的 Stack
    使用 typedef 声明的名字在同一时只能代表一个意思。这样就需要创建两个具有不同名字
    的不同容器类。
    我们所需要的是一种使得容器真正独立于类型的方法。

有 3 条重要的规则规定了如何创建类模板
1）所有定义在类声明之外的操作都必须是模板函数
2）任何将一个模板类的名作为类型的使用都必须参数化
3）当使用类模板时，编译器必须能够找到它的操作的定义

    在我们对创建类模板的 3 个规则的讨论中，很重要的一点就是要理解类模板的名字，
形参化这个名字以及实例化这个名字之间的区别。
    Stack 这是一个类模板的名字，创建一个类的模式。它绝不会是一个类型的名字。
    Stack<ElementType> 这是一个类模板形参化的名字；当使用一个特定的类型替换了
 类型形参 ElementType 后，它就变成了一个类型
    Stack<double> 这是一个类型，可以用来声明元素类型为 double 的栈


*/
