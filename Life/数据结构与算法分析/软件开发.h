#pragma once
class 软件开发
{
};


/* ------------------------------ 学习笔记 ------------------------------ *
章节内容
・问题分析和需求规格说明书
・设计
・编码
・测试、运行和调试
・维护
*/

/* ------------------------------ 学习笔记 ------------------------------ *
问题分析和需求规格说明
    前置条件：前置条件描述了在一个程序单元或一系列程序单元被执行之前的处理状态。
    后置条件：后置条件描述了在程序单元执行之后的处理状态

    制定一个需求规格说明并不是如此简单如此直接的。对这类问题的最初描述往往都是
    含糊和不准确的。提出问题的人往往并没有很好地理解问题本身，也不知道该如何去
    解决问题，或者不知道计算机到底具有什么样的能力以及有那些限制。形成一个解决
    问题所需要的行为的描述将花费相当的时间和努力：提出问题、收集信息、澄清含糊
    的地方等。

    备注：需求规格说明有一系列的形式化方法，例如 VDM（维也纳开发犯法），以及Larch

设计（自顶向下与面向对象设计）
    通常不可能在一开始就看清楚或预见到整个问题的一个完全解决方案。
    ・自顶向下・的方法将原始问题划分成更简单的子问题，每个子问题可以被单独考虑。一些
    或全部这些子问题可能仍然相当复杂，这个模块化的过程可以重复地应用到这些子问题
    上，直到获得的子问题都能够被解决为止。这些问题的解决方案就组成了解决原始问题
    的系统。
    示例：
    财政补助问题
        获取记录
            获取注册记录
            获取财政补助记录
        处理记录
            提取记录
            获取更新
            修改记录
                查找
                修改
        产生报表

    ・面向对象设计・的模块化主要是通过确认一系列的对象来实现的，每个这种对象都是由
    数据和在数据上的操作构成的，可以建模实际对象，并互相交互从而解决问题。

    小规模设计：非结构化算法与结构化算法

编码
    ・程序和子程序必须具有良好的结构
    前置条件和后置条件可以使用断言来检测
    ・所有的源代码都应该有相应的文档
    每个程序应该包括公开的文档：说明程序用途的简要描述；前置条件和其他假设；程序的
    输入，它产生的输出，以及后置条件；关于程序所实现的特殊算法，所使用的类的注释，
    以及给出额外信息的参考书目和手册；关于程序员的信息，例如程序员的名字，程序编写
    的日期，修改的日期（以及在程序设计课程中指导老师所要求的其他信息）；应该为每个
    子程序加上文档。特别地，子程序应该包括（至少）一个简明的描述来给出它的用途、前置
    条件和后置条件等；应该使用注释来解释关键的代码和/或目标或设计不明显的代码段。不过，
    不要插入不必要的注释而扰乱代码；使用有意义的标识符。

测试、运行和调试
    在软件开发的任何一个阶段都可能发生错误。“V”型生命周期模型。
    对一个程序的彻底测试会增强人们对这个程序正确性的信心，但是需要意识到的是，
    几乎不可能使用每个可能的测试数据集来测试一个程序。
    编程作业所编写的程序中的错误其影响通常不会很严重。也许学生只是丢失一点作业
    分数，或者他可能非常幸运，因为给成绩的人没有注意到这个错误。但是，对于现实
    世界中的问题，不是课程成绩，而是其他很重要的东西会受到危害：金钱、工作、甚至
    生命。

维护
    ・隐匿的错误被发现
    ・提升性能、添加新特性等
    ・政府政策和规定的改变或者公司组织结构的改变

    伪代码：伪代码程序设计语言是自然语言、符号、术语以及通常使用在一种或多种高级
    程序设计语言中的一些特性的混合。因为没有标准的语法，一个程序员和另一个程序员
    使用的伪代码是不同的。

    验证（我们是否正确的制造了产品）指的是检查程序文档，模块以及可能的产品是正确的
    和完备的，并且它们互相之间以及与前一阶段中的相应部分都是一致的。确认（我们是否
    制造了正确的产品）则是检查这些产品是否符合问题的需求规格说明。
*/

/* ------------------------------ 学习笔记 ------------------------------ *
折半查找的需求规格说明
目标：对一个有序列表进行折半查找
前置条件：列表元素按照升序排列并被存储在一个数组 arr 中。这个列表具有 n 个元素，
    这里 n 是一个正整数。item 是被查找的值，它的类型和数组元素的类型相同。
后置条件：如果查找成功，found 为真，而 mid 是 item 在数组中的位置；否则，found
    为假。
*/

/*
    简要描述：对存储在一个数组中的有序列表进行折半查找

    前置条件：数组 arr 的元素按照升序存储，在前 n 个元素中查找 item
    后置条件：如果搜索成功，found 为 true，并且 mid 是 item 在数组中
              的位置；否则，found 为 false。
*/
void BinarySearch(int arr[], int n, int item, bool& found, int& mid);

// 折半查找
void recBinarySearch(int a[], int first, int last, int item,
    bool& found, int& loc);
/*
使用折半查找方法递归的搜索（子）列表 a[first],...,a[last] 来查找 item
前置条件：存储在数组 a 中元素按照升序排序；item 的类型和数组元素的类型相同
后置条件：如果搜索成功，返回 found = true 以及 item 的位置 loc = position；否则返回 found = false
*/

// 判断一个非负整数是否是回文数字
bool HuiWenNumber(int number, int numDigits);
/*
判断一个非负整数是否是一个回文数字
前置条件：无
后置条件：返回 ture 表示 number 是回文数字；否则，不是回文数字
*/
